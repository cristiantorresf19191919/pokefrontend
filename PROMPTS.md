First prompt for scaffolding and architecturing the app


This is a robust, production-ready stack. To achieve **SEO friendliness** with React while using this stack, **Next.js (App Router)** is the de facto standard architecture today. It allows you to render the initial HTML on the server (critical for SEO) while hydrating the client with Apollo and Zustand.

Here is the architecture blueprint tailored to your specific **Pokemon Schema**, **Postman Collection**, and the **Feature-Based** philosophy.

-----

### 1\. The Directory Structure (Feature-First)

We organize by **Domain** (Pokemon, Auth) rather than **Type** (Components, Hooks).

```text
src/
  app/                        <-- Next.js App Router (Pages/Routes)
    layout.tsx                <-- Wraps ApolloWrapper & ThemeRegistry
    page.tsx                  <-- Redirects to /pokedex
    pokedex/
      page.tsx                <-- Server Component (SEO Metadata here)
  features/
    auth/                     <-- Feature: Authentication
      components/             <-- LoginForm.tsx
      graphql/                <-- login.graphql
      hooks/                  <-- useLogin.ts
    pokemon/                  <-- Feature: Pokemon Domain
      components/             <-- PokemonList.tsx, PokemonCard.tsx
      graphql/                <-- pokemons.graphql, pokemonDetails.graphql
      hooks/                  <-- usePokemonList.ts (The Logic Layer)
      stores/                 <-- usePokemonFilterStore.ts (Zustand)
      types/                  <-- Generated types specific to this feature
  lib/
    apollo/                   <-- Apollo Client Setup (SSR + Client)
    graphql/                  <-- Codegen configuration
    theme/                    <-- MUI Theme Registry
```

-----

### 2\. Infrastructure Layer: GraphQL & Codegen

Do not write TypeScript interfaces manually. We will generate them from your Schema.

**`codegen.yml` Configuration:**

```yaml
overwrite: true
schema: "http://localhost:8080/graphql"
documents: "src/features/**/graphql/*.graphql"
generates:
  src/gql/:
    preset: "client"
    plugins: []
```

-----

### 3\. State Management Layer (The Hybrid Approach)

You requested **Zustand for filtering** and **Apollo for caching**. This is the perfect "Separation of Concerns."

#### A. Client State: Zustand (Filtering & Sorting)

We keep the UI state (Sort By, Filters) in Zustand. This does not need to be in the URL query params initially, but for SEO, it's better to sync them. For this architecture, we will treat it as a "Client Preference" store.

```typescript
// src/features/pokemon/stores/usePokemonFilterStore.ts
import { create } from 'zustand';

type SortOption = 'name' | 'number';

interface PokemonFilterState {
  sortBy: SortOption;
  searchQuery: string;
  setSortBy: (sort: SortOption) => void;
  setSearchQuery: (query: string) => void;
}

export const usePokemonFilterStore = create<PokemonFilterState>((set) => ({
  sortBy: 'number', // Default matching your Postman collection
  searchQuery: '',
  setSortBy: (sortBy) => set({ sortBy }),
  setSearchQuery: (searchQuery) => set({ searchQuery }),
}));
```

#### B. Server State: Apollo (Data Fetching)

We map your specific schema to a custom hook. This hook listens to the Zustand store to know *what* to fetch.

```typescript
// src/features/pokemon/hooks/usePokemonList.ts
import { useQuery } from '@apollo/client';
import { graphql } from '@/gql'; // Generated by codegen
import { usePokemonFilterStore } from '../stores/usePokemonFilterStore';

// Define the query based on your Schema
const GET_POKEMONS = graphql(`
  query GetPokemons($first: Int, $after: String, $sortBy: String) {
    pokemons(first: $first, after: $after, sortBy: $sortBy) {
      edges {
        node {
          id
          name
          number
          imageUrl
          types
        }
        cursor
      }
      pageInfo {
        hasNextPage
        endCursor
      }
      totalCount
    }
  }
`);

export const usePokemonList = () => {
  // 1. Read Filter State from Zustand
  const { sortBy } = usePokemonFilterStore();

  // 2. Execute Apollo Query
  const { data, loading, fetchMore, error } = useQuery(GET_POKEMONS, {
    variables: { 
      first: 20, 
      sortBy: sortBy // Automatically refetches when Zustand changes!
    },
    notifyOnNetworkStatusChange: true, // For smooth pagination loading states
  });

  // 3. Abstract the Relay-style pagination logic (Edges/Nodes)
  const loadMore = () => {
    if (data?.pokemons.pageInfo.hasNextPage) {
      fetchMore({
        variables: { after: data.pokemons.pageInfo.endCursor },
      });
    }
  };

  return {
    pokemons: data?.pokemons.edges.map(edge => edge.node) || [],
    totalCount: data?.pokemons.totalCount,
    isLoading: loading,
    loadMore,
    hasNextPage: data?.pokemons.pageInfo.hasNextPage,
    error
  };
};
```

-----

### 4\. The Feature Layer: Auth (Using your Mutation)

Based on your Postman collection, we handle the login and store the token.

```typescript
// src/features/auth/hooks/useLogin.ts
import { useMutation } from '@apollo/client';
import { graphql } from '@/gql';
import Cookies from 'js-cookie'; // Better for SEO/Next.js than localStorage

const LOGIN_MUTATION = graphql(`
  mutation Login($username: String!, $password: String!) {
    login(username: $username, password: $password) {
      success
      token
      message
    }
  }
`);

export const useLogin = () => {
  const [loginMutation, { loading, error }] = useMutation(LOGIN_MUTATION);

  const login = async (username: string, password: string) => {
    const response = await loginMutation({ variables: { username, password } });
    
    if (response.data?.login.success && response.data.login.token) {
      // Store token in Cookie for Middleware access (SEO friendly protection)
      Cookies.set('auth_token', response.data.login.token); 
      return true;
    }
    return false;
  };

  return { login, isLoading: loading, error };
};
```

-----

### 5\. The UI Layer: Material UI Implementation

Here we combine the **Technical Logic** (MUI) with the **Business Logic** (Hooks).

```tsx
// src/features/pokemon/components/PokedexView.tsx
'use client'; // Client Component (Required for Zustand/Apollo interactions)

import { Grid, Box, Select, MenuItem, Button, CircularProgress } from '@mui/material';
import { usePokemonList } from '../hooks/usePokemonList';
import { usePokemonFilterStore } from '../stores/usePokemonFilterStore';
import { PokemonCard } from './PokemonCard';

export const PokedexView = () => {
  // Access Logic Layers
  const { pokemons, loadMore, isLoading, hasNextPage } = usePokemonList();
  const { sortBy, setSortBy } = usePokemonFilterStore();

  return (
    <Box sx={{ p: 3 }}>
      {/* Control Bar */}
      <Box sx={{ display: 'flex', justifyContent: 'flex-end', mb: 3 }}>
        <Select
          value={sortBy}
          onChange={(e) => setSortBy(e.target.value as 'name' | 'number')}
          size="small"
          sx={{ minWidth: 150 }}
        >
          <MenuItem value="number">Sort by ID</MenuItem>
          <MenuItem value="name">Sort by Name</MenuItem>
        </Select>
      </Box>

      {/* Grid Layout */}
      <Grid container spacing={2}>
        {pokemons.map((pokemon) => (
          <Grid item xs={12} sm={6} md={4} key={pokemon.id}>
            <PokemonCard pokemon={pokemon} />
          </Grid>
        ))}
      </Grid>

      {/* Infinite Scroll / Load More Trigger */}
      <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}>
        {isLoading ? (
          <CircularProgress />
        ) : (
          hasNextPage && (
            <Button variant="outlined" onClick={loadMore}>
              Load More
            </Button>
          )
        )}
      </Box>
    </Box>
  );
};
```

-----

### 6\. SEO Strategy (The "Friendly" Part)

Since we are fetching data on the client side (infinite scroll), Google *can* crawl it, but it's not perfect. To make it **SEO Friendly**, the specific Pokemon Detail page (`/pokemon/:id`) should be **Server Rendered**.

**How to handle this in `src/app/pokemon/[id]/page.tsx`:**

1.  **Generate Metadata:** Fetch the Pokemon name/image on the server to populate `<title>` and `<meta property="og:image">`.
2.  **Pre-fetch Data:** Use an Apollo Client instance on the server (RSC) to fetch the initial data, then pass it to the client cache.

<!-- end list -->

```typescript
// src/app/pokemon/[id]/page.tsx (Server Component)
import { getClient } from '@/lib/apollo/client'; // Server-side Apollo Client
import { GET_POKEMON_DETAILS } from '@/features/pokemon/graphql/queries';

export async function generateMetadata({ params }) {
  const { data } = await getClient().query({ 
    query: GET_POKEMON_DETAILS, 
    variables: { id: parseInt(params.id) } 
  });
  
  return {
    title: `${data.pokemon.name} | Pokedex`,
    description: `Details for Pokemon #${data.pokemon.number}`,
    openGraph: {
        images: [data.pokemon.imageUrl]
    }
  };
}

export default function PokemonPage({ params }) {
  // Render the view, passing initial data if needed
  return <PokemonDetailView id={params.id} />;
}
```

### Next Steps for You

1.  **Initialize Next.js:** `npx create-next-app@latest my-pokedex --typescript --eslint`
2.  **Install Deps:** `npm install @mui/material @emotion/react @emotion/styled @apollo/client graphql zustand js-cookie`
3.  **Run Codegen:** Set up the `.yml` file and run the generator to get your types.

This architecture ensures that as you add features (e.g., "Team Builder", "Battle Simulator"), your `features/pokemon` folder remains clean, your `stores` manage complex interaction, and Apollo handles the heavy lifting of caching your data.

