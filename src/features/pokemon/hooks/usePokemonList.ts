'use client';

import { useQuery, useApolloClient } from '@apollo/client/react';
import { graphql } from '@/gql'; // Generated by codegen
import { usePokemonFilterStore } from '../stores/usePokemonFilterStore';
import { GetPokemonsQuery } from '@/gql/graphql';
import { useRef, useEffect } from 'react';
import { useLoadingStore } from '@/lib/loading/useLoadingStore';

// Define the query based on your Schema
const GET_POKEMONS = graphql(`
  query GetPokemons($first: Int, $after: String, $sortBy: String) {
    pokemons(first: $first, after: $after, sortBy: $sortBy) {
      edges {
        node {
          id
          name
          number
          imageUrl
          abilities {
            name
            isHidden
          }
        }
        cursor
      }
      pageInfo {
        hasNextPage
        endCursor
      }
      totalCount
    }
  }
`);

export const usePokemonList = (initialData?: GetPokemonsQuery | null) => {
  const client = useApolloClient();
  const hasWrittenInitialData = useRef(false);
  
  // Write initial server data to cache for proper SSR hydration
  useEffect(() => {
    if (initialData && !hasWrittenInitialData.current) {
      client.writeQuery({
        query: GET_POKEMONS,
        variables: { first: 20, sortBy: 'number' },
        data: initialData,
      });
      hasWrittenInitialData.current = true;
    }
  }, [initialData, client]);

  // 1. Read Filter State from Zustand
  const { sortBy } = usePokemonFilterStore();

  // 2. Execute Apollo Query (will use cached data if available)
  const { data, loading, fetchMore, error } = useQuery(GET_POKEMONS, {
    variables: { 
      first: 20, 
      sortBy: sortBy // Automatically refetches when Zustand changes!
    },
    notifyOnNetworkStatusChange: true, // For smooth pagination loading states
    fetchPolicy: initialData ? 'cache-first' : 'cache-and-network', // Use cache if we have initial data
  });

  // Track loading state globally
  const setLoading = useLoadingStore((state) => state.setLoading);
  useEffect(() => {
    setLoading(loading);
  }, [loading, setLoading]);

  // 3. Abstract the Relay-style pagination logic (Edges/Nodes)
  const loadMore = () => {
    if (data?.pokemons.pageInfo.hasNextPage) {
      fetchMore({
        variables: { after: data.pokemons.pageInfo.endCursor },
      });
    }
  };

  return {
    pokemons: data?.pokemons.edges.map(edge => edge.node) || [],
    totalCount: data?.pokemons.totalCount,
    isLoading: loading,
    loadMore,
    hasNextPage: data?.pokemons.pageInfo.hasNextPage,
    error
  };
};


