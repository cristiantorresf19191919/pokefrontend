'use client';

import { useQuery, useApolloClient } from '@apollo/client/react';
import { graphql } from '@/gql'; // Generated by codegen
import { usePokemonFilterStore } from '../stores/usePokemonFilterStore';
import { GetPokemonsQuery } from '@/gql/graphql';
import { useRef, useEffect, useState } from 'react';
import { useLoadingStore } from '@/lib/loading/useLoadingStore';

// Define the query based on your Schema
const GET_POKEMONS = graphql(`
  query GetPokemons($first: Int, $after: String, $sortBy: String) {
    pokemons(first: $first, after: $after, sortBy: $sortBy) {
      edges {
        node {
          id
          name
          number
          imageUrl
          abilities {
            name
            isHidden
          }
        }
        cursor
      }
      pageInfo {
        hasNextPage
        endCursor
      }
      totalCount
    }
  }
`);

export const usePokemonList = (initialData?: GetPokemonsQuery | null) => {
  const client = useApolloClient();
  const hasWrittenInitialData = useRef(false);
  const previousSortBy = useRef<string | null>(null);
  const [hasInitialData] = useState(!!initialData);
  
  // Write initial server data to cache for proper SSR hydration
  useEffect(() => {
    if (initialData && !hasWrittenInitialData.current) {
      client.writeQuery({
        query: GET_POKEMONS,
        variables: { first: 10, sortBy: 'number' },
        data: initialData,
      });
      hasWrittenInitialData.current = true;
    }
  }, [initialData, client]);

  // 1. Read Filter State from Zustand
  const { sortBy } = usePokemonFilterStore();

  // 2. Execute Apollo Query (will use cached data if available)
  // When sortBy changes, Apollo will automatically refetch with new variables
  const { data, loading, fetchMore, error, refetch } = useQuery(GET_POKEMONS, {
    variables: { 
      first: 10, 
      sortBy: sortBy,
      // Always start from the beginning - don't pass 'after' cursor
      after: undefined,
    },
    notifyOnNetworkStatusChange: true, // For smooth pagination loading states
    fetchPolicy: hasInitialData ? 'cache-first' : 'cache-and-network',
  });
  
  // Refetch when sortBy changes to ensure we get fresh data from the beginning
  useEffect(() => {
    if (previousSortBy.current !== null && previousSortBy.current !== sortBy) {
      refetch({
        first: 10,
        sortBy: sortBy,
        after: undefined,
      });
    }
    previousSortBy.current = sortBy;
  }, [sortBy, refetch]);

  // Track loading state globally
  const setLoading = useLoadingStore((state) => state.setLoading);
  useEffect(() => {
    setLoading(loading);
  }, [loading, setLoading]);

  // 3. Abstract the Relay-style pagination logic (Edges/Nodes)
  const loadMore = () => {
    const queryData = data as GetPokemonsQuery | undefined;
    if (queryData?.pokemons?.pageInfo?.hasNextPage) {
      fetchMore({
        variables: { 
          first: 10,
          after: queryData.pokemons.pageInfo.endCursor,
          sortBy: sortBy,
        },
        // Merge the new results with existing ones
        updateQuery: (prev: unknown, { fetchMoreResult }: { fetchMoreResult: unknown }) => {
          const prevQuery = prev as GetPokemonsQuery | undefined;
          const moreResult = fetchMoreResult as GetPokemonsQuery | undefined;
          
          if (!prevQuery?.pokemons || !moreResult?.pokemons) {
            return prevQuery || moreResult || prev;
          }
          
          return {
            ...prevQuery,
            pokemons: {
              ...prevQuery.pokemons,
              edges: [...prevQuery.pokemons.edges, ...moreResult.pokemons.edges],
              pageInfo: moreResult.pokemons.pageInfo,
            },
          };
        },
      });
    }
  };

  const queryData = data as GetPokemonsQuery | undefined;

  return {
    pokemons: queryData?.pokemons?.edges?.map((edge) => edge.node) || [],
    totalCount: queryData?.pokemons?.totalCount ?? 0,
    isLoading: loading,
    loadMore,
    hasNextPage: queryData?.pokemons?.pageInfo?.hasNextPage ?? false,
    error
  };
};


